/* Include s3d symbols */
#include <Script3d.h>
#include <Camera.s3d.h>

#include <map/level.s3d>
#include <network/network.s3d>
#include <player/player.s3d>
#include <player/enemy.s3d>


#define MY_PLAYER_ID 	4

#define CAM_GLOBAL    	0
#define CAM_FPV 		1

#define N_PLAYERS	 	8
#define N_ENEMIES 		(N_PLAYERS-1)

#define SCORE_PDU_PERIOD  1000


// Global scene parameters
SET SCENE_FOV  = 60;
SET SCENE_NEAR = 0.3;
SET SCENE_FAR  = 200;

// Camera globals
var camType;
var globalCamDefaultPos = [2.0, 5.0, 30.0];

// Light globals
var Light0;
var PosL = [0.0, 30.0, 0.0];	// default light position

// Level globals
var myLevel;

// Players globals
var myPlayer;
var enemies = array(N_PLAYERS);

// Audio
var start_fx;

// Network
var myNetwork;

// Function declarations
function initCamera(type, pos, dir);
function updateCamera();
function DrawGrid(col, size);


/* Draw the player health bar */
function drawHPBar(hp, max_hp)
{
	ConsoleColor(0.4, 0.6, 1.0);
	ConsoleFilledRect(0.05, 0.1, 0.15, 0.05);
	ConsoleText(0.21, 0.06, "HP");
	ConsoleColor(0, 0, 0);
	ConsoleFilledRect(0.06, 0.09, 0.13, 0.03);
	
	if (1.0*hp/max_hp <= 0.25)
		ConsoleColor(1, 0, 0);	// red
	else if (1.0*hp/max_hp < 0.5)
		ConsoleColor(1, 1, 0);  // yellow
	else
		ConsoleColor(1, 1, 1);  // white
		
	ConsoleFilledRect(0.06, 0.09, 0.13*hp/max_hp, 0.03);
}


/* Draw the HUD and secondary information */
function drawHUD(t_respawn_left)
{
	// Show stats
	ConsoleFont("Impact", 20);
	ConsoleColor(0.4, 0.6, 1.0);
	ConsoleText(0.05, 0.17, "Ammo:    " + str(myPlayer.getRemainingShots()) + "/" + str(myPlayer.getMagazineSize()));
	ConsoleText(0.05, 0.12, "K/D:  " + str(myPlayer.kills) + "/" + str(myPlayer.deaths));
	drawHPBar(myPlayer.getHP(), SWAT_HEALTH_POINTS);
	
	// Show notifications
	if (myPlayer.isReloading()) {
		ConsoleFont("Impact", 18);
		ConsoleColor(1, 0.6, 0.2);
		ConsoleText(0.45,0.9, "RELOADING");
	}
	
	// Draw crosshair
	var scope1 = [0.5, 0.48, 0.5, 0.52];
	var scope2 = [0.485, 0.5, 0.515, 0.5];
	ConsoleColor(1,0,0);
	ConsoleWidth(3);
	ConsoleLines(scope1);
	ConsoleLines(scope2);
	
	// Show respawn interface
	if (t_respawn_left >= 0) {
		// Grey-out the background
		ConsoleColor(0.5, 0.5, 0.5, 0.6);
		ConsoleFilledRect(0, 1, 1, 1);
		// Respawn time counter
		ConsoleFont("Impact", 100);
		ConsoleColor(0.4, 0.6, 1.0);
		ConsoleText(0.45,0.5, str(t_respawn_left / 1000));
	}
}


/* Draw the overlay scoreboard */
function drawScoreBoard()
{
	var offset = 0;
	// box
	ConsoleColor(0.4, 0.6, 1.0);
	ConsoleFilledRect(0.24, 0.76, 0.52, 0.52);
	ConsoleColor(0.9, 0.9, 0.9);
	ConsoleFilledRect(0.25, 0.75, 0.5, 0.5);
	// header
	ConsoleFont("Impact", 20);
	ConsoleColor(0.0, 0.0, 0.0);
	ConsoleText(0.3, 0.7, "Player ID");
	ConsoleText(0.55, 0.7, "K");
	ConsoleText(0.65, 0.7, "D");
	// scores
	ConsoleFont("Impact", 16);
	for (var i=0; i<N_PLAYERS; i++) {
		if (enemies[i].active) {
			ConsoleColor(0.0, 0.0, 0.0);
			ConsoleText(0.3, 0.62 - offset, str(i));
			ConsoleText(0.55, 0.62 - offset, str(enemies[i].kills));
			ConsoleText(0.65, 0.62 - offset, str(enemies[i].deaths));
			offset += 0.05;
		} else if (i == MY_PLAYER_ID) {
			ConsoleColor(1.0, 0.0, 0.0);
			ConsoleText(0.3, 0.62 - offset, str(i));
			ConsoleText(0.55, 0.62 - offset, str(myPlayer.kills));
			ConsoleText(0.65, 0.62 - offset, str(myPlayer.deaths));
			offset += 0.05;
		}
	}
}


/* Periodically send update PDUs to the other hosts. */
function sendPeriodicalUpdates()
{
	static var last_score_update = 0;
	var t = getTime();
	
	if (t - last_score_update > SCORE_PDU_PERIOD) {
		var sc_pdu = myNetwork.craftScorePDU(myPlayer, enemies);
		myNetwork.sendPDU(sc_pdu);
		last_score_update = t;
	}
}


/* onDownload() is performed at the beginning and downloads the files needed
 * by the application.
 */
function OnDownload()
{
	FileDownload("resources.zip");
}


/* onInit() is called after onDownload() and performs the initialization routine */
function OnInit(params)
{
	outputln("Initializing the game...");
	
	// Initialize light
	Light0 = CVmLight();
	Light0.SetPosition(PosL);
	Light0.SetAmbient(0.6, 0.6, 0.6);
	Light0.SetDiffuse(1, 0.85, 0.85);
	Light0.Enable();

	myNetwork = NetworkManager();
	myNetwork.init(MY_PLAYER_ID);

	myLevel = Level();
	myLevel.init("level_3D.txt");
	
	myPlayer = Player();
	var spawn_pos = myLevel.getRandomFloorPosition();
	var spawn_dir = myLevel.getNonWallDirection(spawn_pos);
	outputln("Spawned in " + str(spawn_pos));
	myPlayer.init(spawn_pos, spawn_dir, [0,1,0], myLevel, myNetwork);
	
	for (var i=0; i<N_PLAYERS; i++) {
		enemies[i] = Enemy();
		enemies[i].init(i, false, [0,0,0], 0, 0, myPlayer, myLevel, myNetwork);
	}
	
	// Initialize camera
	//initCamera(CAM_GLOBAL, globalCamDefaultPos, [0,0,-1]);
	initCamera(CAM_FPV, myPlayer.getPosition() + [0,1.7,0], myPlayer.getDirection());
	
	// Set the mouse cursor at the center
	SetCursorPos(0.5, 0.5);
	
	start_fx = CVmVRAWAV("start.wav");
	start_fx.play();
	outputln("Ready to play!");
}


/* onFrame() is called periodically (by default 100Hz) and manages the
 * graphics. It is the only place where graphics commands take effect.
 */
function OnFrame()
{	
	var t = getTime();
	var t_respawn_left = myPlayer.respawn_time - t;
	
	// Check if should quit the application
	if (keypressed(VK_ESCAPE)) {
		CVmWebBrowser().Quit();
	}
	
	// Send periodical updates
	sendPeriodicalUpdates();
	
	updateCamera();
	SceneBegin();
	//DrawGrid([0.5, 0.5, 0.5], 100);
	
	if (t_respawn_left <= 0)
		myPlayer.update();

	myLevel.draw();

	for (var i=0; i<N_PLAYERS; i++) {
		if (enemies[i].active) {
			enemies[i].update();
			enemies[i].draw();	
		}
	}
	if (myPlayer.hp <= 0) {
		myPlayer.incrementDeaths();
		myPlayer.notifyDeath();
		myPlayer.respawn();
	}
	if (t_respawn_left <= 0)
		myPlayer.draw();
	
	drawHUD(t_respawn_left);
	if (keypressed(VK_TAB)) {
		drawScoreBoard();
	}
	
	ConsoleFinish();
	ShowCursor(false);
	SetCursorPos(0.5, 0.5);
	
	SceneEnd();
}


/* DownloadReady() is called everytime a download in OnDownload() completes. */
function DownloadReady(RequestID) {}


/* onTimer() runs periodically (by default 100 Hz) and manages all
 * the periodic routines that are not strictly graphical.
 */
function OnTimer() 
{
	var pdu;
	
	// Try to acquire a PDU 
	pdu = myNetwork.receivePDU();
	
	// Handle the PDU, if any
	if (pdu != null) {
		
		// Position update:
		// [0]-typePDU, [1]-sender, [2,3,4]-posXYZ, [5]-angle, [6]-visible/hidden
		if (pdu[0] == POSITION_PDU) {
			var player_id = pdu[1];
			enemies[player_id].active = true;
			enemies[player_id].changePosition([pdu[2], pdu[3], pdu[4]], pdu[5], pdu[6]);
		}
		
		// Bullet update:
		// [0]-typePDU, [1]-sender, [2]-weapon, [3]-bull_idx, [4,5,6]-posXYZ, [7,8,9]-dirXYZ, [10]-life, [11]-uniqueID
		if (pdu[0] == BULLET_PDU) {
			var player_id = pdu[1];
			enemies[player_id].setBullet(
					pdu[2]*ROCKET_BULLETS + pdu[3], 
					[pdu[4], pdu[5], pdu[6]],
					[pdu[7], pdu[8], pdu[9]],
					pdu[10],
					pdu[11]
			);
		}
		
		// Bullet hit notification:
		// [0]-typePDU, [1]-player_hit, [2]-hitter, [3]-weapon, [4]-bull_idx
		if (pdu[0] == HIT_PDU) {
			var player_hit_id = pdu[1];
			var hitter_id = pdu[2];
			var weap = pdu[3];
			var bull_idx = pdu[4];
			if (hitter_id == MY_PLAYER_ID) {
				myPlayer.handleHitTarget(weap, bull_idx);
			} else {
				enemies[hitter_id].bullets[weap*ROCKET_BULLETS + bull_idx] = null;
			}
		}
		
		// Kill notification:
		// [0]-typePDU, [1]-killed, [2]-killer
		if (pdu[0] == KILL_PDU) {
			var killed = pdu[1];
			var killer = pdu[2];
			enemies[killed].incrementDeaths();
			if (killer == MY_PLAYER_ID) {
				myPlayer.incrementKills();
			} else {
				enemies[killer].incrementKills();
			}
		}
		
		// Score update:
		// [0]-typePDU, [1]-sender, [2+2*i]-player_i_kills, [3+2*i]-player_i_deaths
		if(pdu[0] == SCORE_PDU)	{
			var player_id = pdu[1];
			for (var i=0; i<N_PLAYERS; i++){
				if ((i != MY_PLAYER_ID) && (enemies[i].active)) {
					enemies[i].tryIncrementKills(pdu[2+2*i]);
					enemies[i].tryIncrementDeaths(pdu[3+2*i]);	
				} else if (i == MY_PLAYER_ID) {
					myPlayer.tryIncrementKills(pdu[2+2*i]);
					myPlayer.tryIncrementDeaths(pdu[3+2*i]);
				}
			}
		}
	}
}


/* onEvent() is called whenever the application receives a message. */
function OnEvent(eventID, wparam, lparam) {}


/* onError() is called when the applications produces an error */
function OnError() {}


/* onExit() is called when the application is about to terminate. */
function OnExit() {}


/* Initialize the camera */
function initCamera(type, pos, dir)
{
	camType = type;
	CameraGetCurrent().SetPosition(pos);
	CameraGetCurrent().SetDirection(dir);
}


/* Update the camera */
function updateCamera()
{	
	if (camType == CAM_GLOBAL) {
		CameraMoveMouse_MBL_LC();
	}
	
	if (camType == CAM_FPV) {
		myPlayer.obj.hide();
		// set the camera position slightly behind the head to avoid see-through walls effect
		CameraGetCurrent().SetPosition(myPlayer.getPosition() + [0,1.5,0] - 0.25*myPlayer.getDirection());
		CameraGetCurrent().SetDirection(myPlayer.getDirection());
	}
}


function DrawGrid(col, size)
{
	// Save current OpenGL state
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	
	glLineWidth(1);
	glDisable(GL_LIGHTING);
	glColor(col);
	var max = size / 2.0;
	var min = -max;	
	var step = size / 10.0;
	
	glBegin(GL_LINES);
		for (var i = min; i <= max; i += step)
		{
			glVertex(i, 0, max);
			glVertex(i, 0, min);
			
			glVertex(max, 0, i);
			glVertex(min, 0, i);
		}
	glEnd();
	
	// Restore previous OpenGL state
	glPopAttrib();
}
