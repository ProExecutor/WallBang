class Enemy {
	
	var id;
	var active;
	var pos;
	var angle;
	var score;
	var bullets;
	var last_uid;
	
	// graphics
	var lower_mesh;
	var upper_mesh;
	var lower_obj;
	var upper_obj;
	var obj;
	
	// collision detection
	var my_player;
	var level;
	
	// connection
	var network;
	
	init(enemy_id, act, p, a, sc, pl, lvl, net);
	draw();
	update();
	changePosition(new_pos, new_angle);
	setRotation(angle);
	setBullet(idx, pos, dir, life, uid);
	IncrementScore();
	tryIncrementScore(new_score);
};


function Enemy::init(enemy_id, act, p, a, s, pl, lvl, net)
{
	id = enemy_id;
	active = act;
	pos = p;
	angle = a;
	score = s;
	my_player = pl; 
	level = lvl;
	network = net;
	
	bullets = array(N_BULLETS_PLAYER);
	last_uid = array(N_BULLETS_PLAYER);
	for (var i=0; i<N_BULLETS_PLAYER; i++) {
		bullets[i] = null;
		last_uid[i] = -1;	
	}
		
	lower_mesh = CVmNewMesh("swat_lower.aam");
	var sf = lower_mesh.normalize(1);
	upper_mesh = CVmNewMesh("swat_upper.aam");
	upper_mesh.scale(sf);
	
	lower_obj = CVmObj(lower_mesh);
	upper_obj = CVmObj(upper_mesh);
	obj = CVmObj();
	obj.addchild(upper_obj);
	obj.addchild(lower_obj);
	// TODO add weapon mesh
	obj.SetPosition(pos);
	obj.SetRotation(angle);
}


function Enemy::draw()
{
	obj.Draw(VR_FRAMENUMBER, 1);
	
	for (var i=0; i<N_BULLETS_PLAYER; i++) {
		if (bullets[i] != null) {
			bullets[i].draw();
		}
	}
}


function Enemy::update()
{
	for (var i=0; i<N_BULLETS_PLAYER; i++) {
		if (bullets[i] != null) {
			var b_life_res = bullets[i].update(true, my_player.position);
			
			if (b_life_res <= 0) {
				// stop the projectile, for whatever reason
				bullets[i] = null;	
			}
			if (b_life_res == -1) {
				// the bullet hit my player
				var weap, bull_idx;
				outputln("My player was hit!!");
				// TODO apply human damage or area
				if (i < ROCKET_BULLETS) {
					weap = WEAP_ROCKET_TYPE;
					bull_idx = i;
				} else {
					weap = WEAP_RAILGUN_TYPE;
					bull_idx = i - ROCKET_BULLETS;
				}
				var pdu = network.craftHitPDU(id, weap, bull_idx, bullets[i].uid);
				network.sendPDU(pdu);
			}
		}
	}
}


function Enemy::changePosition(new_pos, new_angle)
{
	pos = new_pos;
	angle = new_angle;
	SetRotation(angle);
	obj.SetPosition(pos);
}


function Enemy::setRotation(angle)
{
	obj.setRotation(angle*180.0/PI, 0, 1, 0);
}


/* Create a bullet with the specified parameters or, if it already exists, update it. */
function Enemy::setBullet(idx, pos, dir, life, uid)
{
	if ((bullets[idx] == null) && (uid != last_uid[idx])) {
		// if the bullet does not exist, and the UID is not the same of the last destroyed bullet
		outputln("Creating bullet idx " + str(idx) + " pos " + str(pos) + " dir " + str(dir) + " life " + str(life) + " uid " + str(uid));
		var btype;
		if (idx < ROCKET_BULLETS)
			btype = BULLET_LARGE_TYPE;
		else
			btype = BULLET_SMALL_TYPE;
			
		bullets[idx] = Bullet();
		bullets[idx].init(btype, pos, dir, level, network);
		// Enforce the UID
		bullets[idx].uid = uid;
		last_uid[idx] = uid;
	} else if (bullets[idx] != null) {
		// if the bullet already exists
		bullets[idx].changePosition(pos);
		// bullets[idx].dir = dir;		// unnecessary since direction is constant
		bullets[idx].life = life;
	}
	// check if expired
	if ((bullets[idx] != null) && (bullets[idx].life == 0))
		bullets[idx] = null;
}


function Enemy::incrementScore()
{
	score += 1;
}


function Enemy::tryIncrementScore(new_score)
{
	if (new_score > score)
		score = new_score;
}